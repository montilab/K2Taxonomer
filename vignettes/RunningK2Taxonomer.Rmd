---
title: "Running K2Taxonomer"
output: 
  rmarkdown::html_document:
    toc: true
    df_print: paged
vignette: >
  %\VignetteIndexEntry{RunningK2Taxonomer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message=F, 
  warning=F
)
```

## Requirements

### Load packages
```{r setup}
## K2Taxonomer package
library(K2Taxonomer)

## For creating and manipulating expression sets
library(Biobase)

## For drawing dendrograms
library(ggdendro)
```

### Read in sample `ExpressionSet` object
The main input of `K2Taxonomer` is an `ExpressionSet` object with approximately normally distributed expression values. Here we read in an example data set. See *?sample.ExpressionSet* for more information about these data.

```{r loadData}
data(sample.ExpressionSet)
```

## `K2Taxonomer` basic run

### Generate `K2` object with `K2preproc()` function

The `K2preproc()` initializes the `K2` object and runs pre-processing steps if a *cohort* is specified, which is explained at the end of this document. Here, you can specify all arguments used throughout the analysis. Otherwise, you can specify these arguments within the specific functions for which they are implements. See help pages for more information.

Here we will start by using the defaults.

```{r create}
## Run pre-processing
set.seed(143)
K2res <- K2preproc(sample.ExpressionSet)
```

**Note: This data set is microarray expression data.  If using normalized and log-transformed count data then it's generally recommended that you set *logCounts = TRUE* **. This will more appropriately perform differential gene expression analyses with the `limma` R package.

```{r createCounts, eval=FALSE}
## NOT RUN
K2res <- K2preproc(sample.ExpressionSet,
                   logCounts = TRUE)
```

#### `K2` object structre

`K2Taxonomer` functions create and manipulate S4, `K2` objects, defined within the package. `K2` objects have 5 slots.

- **@eSet** = "ExpressionSet": Original expression data, extracted by `K2eSet()`.
- **@meta** = "list": Named list of parameters for running analysis, extracted by `K2data()`.
- **@dataMatrix** = "matrix": Matrix of processed expression data for running `K2Taxonomer` algorithm, extracted by `K2results`.
- **@info** = "data.frame": Data frame of entered observation-level information, extracted by `K2info()`.
- **@results** = "list": Named list of the results of running the `K2Taxonomer` algorithm, including differential analysis and enrichment results, extracted by `K2results()`
- **@genesets** = "list": Named list of gene sets to run for enrichment analysis, extracted by `K2genesets`.
- **@gene2Pathway** = "character": Named vector of gene set names in which each gene appears, extracted by `K2gene2Pathway`.
- **@geneURL** = "character": Named vector of URLs to link to each gene in the portal, extracted by `K2geneURL()`.
- **@genesetURL** = "character": Named vector of URLs to link to each gene set in the portal, extracted by `K2genesetURL()`.

`K2preproc()` will fill in three of these slots:, **@eSet**, **@meta**, and **@dataMatrix**.
```{r eSetDataMatrix}
## Extract ExpressionSet
K2eSet(K2res)

## Extract dataMatrix
dim(K2data(K2res))
```

**@meta** will be populated by default a set of parameters entered into `K2preproc()`.  Note that for each step, new parameters may be entered, specific to that function.
```{r}
## Extract meta data
names(K2meta(K2res))
```


### Running `K2Taxonomer` algorithm

The `K2Taxonomer` is run by `K2tax()`.  At each recursion of the algorithm, the observations in **@dataMatrix** are split into two sub-groups based on a compilation of repeated K=2 clustering on bootstrapped sampling of features. For each split in the recursion, a stability metric is used to estimate robustness, which takes on values between 0 and 1, where values close to 1 represent the instance in which the same clustering occured in every or nearly every perturbation of a large set of observations. As the number of observations decreasing down the taxonomy the largest possible stability estimate decreases, such that the largest possible stability estimate of triplets and duplets, is 0.67 and 0.50, respectively. 

The parameter, **stabThresh**, controls the minimum value of the stability metric to continue splitting the observations.  By default, **stabThresh** is set to 0, which will run the algorithm until until all observations fall into singlets. If we set **stabThresh = 0.5** the algorithm can not separate duplets, as well as larger sets that demonstrate poor stability when a split is attempted. This can also be set during initialization with `K2preproc()`.

Choosing an appropriate threshold is dependent on the size of the original data set.  For large data sets, choosing small values will greatly increase runtime, and values between 0.8 and 0.7, are generally recommended.

```{r cluster}
## Run Cluster
K2res <- K2tax(K2res,
               stabThresh = 0.5)
```

### `K2Taxonomer` results structure

The **@results** slot of the `K2` object is a named list of the results of running the `K2Taxonomer` algorithm. Each item in the list contains the IDs of the two sets of observations denoted by the split, as well as additional annotation for that split, including the stability estimates.

Each item is assigned a letter ID. If there are more than 26 items, than an additional letter is tacked on, such that the 27th item is named, *AA*, and the 28th item is named **BB**.

```{r results, fig.align='center', fig.width=5, fig.height=5}
## :abels of each partition
names(K2results(K2res))
```

#### Split results
```{r values}
## Get observations defined in each split
K2results(K2res)$A$obs
```

#### Stability metrics

Stability metrics measure the extant to which pairs of observations in the data setpartitioned together for a given split of the data.

```{r stability, fig.align='center', fig.width=5, fig.height=5}
## Get bootstrap probability of this split
K2results(K2res)$A$bootP

## Node stability (Value between 0 and 1. 1 indicating high stability)
K2results(K2res)$A$stability$node

## Stability of each subseqent subgroup.
K2results(K2res)$A$stability$clusters

## Distance matrix indicating pairwise cosine similarity of each observation
splitAstability <- as.matrix(K2results(K2res)$A$stability$samples)

## Show heatmap
hcols <- c("grey", "black")[colnames(splitAstability) %in% K2results(K2res)$A$obs[[1]] + 1]

heatmap(splitAstability, 
        distfun = function(x) as.dist(1-x), 
        hclustfun = function(x) hclust(x, method = "mcquitty"),
        col = hcl.colors(12, "Blue-Red"),
        scale = "none",
        cexRow = 0.7,
        cexCol = 0.7,
        symm = TRUE,
        ColSideColors = hcols,
        RowSideColors = hcols,
        keep.dendro = FALSE)
```

### Generate dendrogram from `K2Taxonomer` results

After running the `K2Taxonomer` algorithm, a `dendrogram` object can be built using `K2dendro()`.
```{r dendrogram, fig.align='center', fig.width=5, fig.height=3}
## Get dendrogram from K2Taxonomer
dendro <- K2dendro(K2res)

## Get dendrogram data
ggdendrogram(dendro)
```

### Annotating `K2Taxonomer` results

A principal motivation behind `K2Taxonomer` is that insight can be garnered and tracjed for various levels in a hierarchical sub-grouping of obervations, such that analytical characterization of different sub-groups throughout the taxonomy serve to both validate and inform about specific sub-groups.

To this end, `K2Taxonomer` runs additional analyses to annotate each split. These analyses include: differential expression analysis using the `limma` package and gene set enrichment testing for both hyperenrichment and differntial analysis of singe-sample enrichment scores estimated using the `GSVA` package.

#### Differential analysis

Differential analysis in `K2Taxonomer` is performed using `limma`. Differential analysis is performed for each partition of the data, comparing the gene expression of each subgroup.

```{r Run differential analysis}
## Run DGE
K2res <- runDGEmods(K2res)

## Get differential results for one split
head(K2results(K2res)$A$dge)

## Concatenate all results and generate table
DGEtable <- getDGETable(K2res)
head(DGEtable)
```

#### Gene set hyperenrichment

`K2Taxonomer` performed both hyperenrichment and differential single-sample enrichment tests based on an input of gene sets using the **genesets** argument, which can be specified in `runGSEmods()`, as demonstrated here, or during initialization with `K2preproc()`. Here, the gene sets are made up.

Gene set hyperenrichment is performed on the top genes for each subgroup, as defined by differential analysis with the `runGSEmods()`. The arguments **qthresh** and **cthresh** specify thresholds for defining top genes, based on *FDR Q-value* and *log fold-change*, respectively. Here, **qthresh = 0.1**, such that genes with *FDR Q-value < 0.1* will be assigned as the top genes for a given partition.

```{r Run Hyperichment}
## Create dummy set of gene sets
genes <- unique(DGEtable$gene)
genesetsMadeUp <- list(
  GS1 = genes[1:50],
  GS2 = genes[51:100],
  GS3 = genes[101:150]
)

## Run gene set hyperenrichment
K2res <- runGSEmods(K2res, 
                     genesets = genesetsMadeUp,
                     qthresh = 0.1)

## Get gene set results for one split
K2results(K2res)$A$gse
```

#### Single-sample gene set enrichment

Single-sample enrichment is performed in two steps.  First, the `GSVA` package is used to generate observation-level enrichment scores, followed by differential analysis using the `limma` package. This is performed by the functions `runGSVAmods()` and `runDSSEmods()`, respectively. Here, we can specify which enrichment algorithm to use when running the `GSVA` functionality and the number of CPU cores to use with the **ssGSEAalg** and **ssGSEAcores** arguments, respectively. These can also be set in the `K2preproc()` function. Note, that the arguments shown are the defaults.

# K2 Taxonomer performed single-sample 
```{r Run ssSGEA, warning=FALSE}
## Create expression matrix with ssGSEA(GSVA) estimates
K2res <- runGSVAmods(K2res, 
                      ssGSEAalg = "gsva",
                      ssGSEAcores = 1,
                      verbose = FALSE)

## Extract ernichment score Expression Set object
K2gSet(K2res)
```


#### Differential single-sample enrichment analysis
```{r Run DSSE}
## Run differential analysis on enrichment score Expression Set
K2res <- runDSSEmods(K2res)

## Get differential results for one split
head(K2results(K2res)$A$dsse)

## Extract table of all hyper and sample-level enrichment tests
K2enrRes <- getEnrichmentTable(K2res)
head(K2enrRes)
```

### Generate interactive portal to explore results

`K2Taxonomer` can automatically generate an interactive web-portal for which to parse through the differential analysis results. This creates it's own sub-directory with a compilable .Rmd file.

```{r portal, eval=FALSE}

## NOT RUN
K2dashboard(K2res,
            analysis_name = "Example",
            output_dir = ".")

```

### Running with `runK2Taxonomer` wrapper

Alternatively, K2Taxonomer can be run in one step with the `runK2Taxonomer()` function.  This function takes all of the same arguments as the `K2preproc()` function, and runs all of the steps above.

```{r RunWrapper}
K2res <- runK2Taxonomer(
  eSet = sample.ExpressionSet,
  genesets = genesetsMadeUp,
  stabThresh = 0.5)
```

## Additional options

### Running with cohorts

If there is replicates in the data or if the user is only interested in capturing subgroup relationships between known groups without partitioning the observations themselves, one can specify the **cohort** variable of interest in the *ExpressionSet* object.

```{r, fig.align='center', fig.width=5, fig.height=3}
## Create set of cohorts from data
sample.ExpressionSet$group <- paste0(sample.ExpressionSet$sex, sample.ExpressionSet$type)

## Run pre-processing
K2res <- K2preproc(sample.ExpressionSet,
                   cohorts = "group")

## Cluster the data
K2res <- K2tax(K2res)

## Create dendrogram
dendro <- K2dendro(K2res)
ggdendrogram(dendro)
```

